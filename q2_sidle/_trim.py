import hashlib
import warnings

import biom
import dask
import numpy as np
import pandas as pd

from q2_sidle._utils import (_setup_dask_client, 
                             _convert_generator_to_seq_block,
                             _convert_generator_to_delayed_seq_block, 
                             _convert_seq_block_to_dna_fasta_format,
                             degen_reps,
                             )

from q2_types.feature_data import (DNAFASTAFormat,
                                   DNAIterator, 
                                   )

def trim_dada2_posthoc(table: biom.Table, 
                       representative_sequences: DNAFASTAFormat, 
                       trim_length:int=0, 
                       hashed_feature_ids:bool=True
                       ) -> (biom.Table, DNAFASTAFormat):
    """
    Trims ASVs generated by DADA2 to a standard length

    Parameters
    ----------
    table : biom.Table
        The feature table
    representative_sequences: DNAFASTAFormat
        The sequences which correspond to the ASV table
    trim_length  : int
        The length to trim the ASVS. If the length is 0, the minimum sequence
        length will be used.
    hash_feature_ids: bool
        Whether feature and sequence IDs should be hashed.
    """

    # Trims the sequences
    rep_seqs = pd.concat(
        axis=0, 
        objs=_convert_generator_to_seq_block(
                representative_sequences.view(DNAIterator))
        )
    if trim_length == 0:
        rep_seqs.dropna(how='any', axis=1, inplace=True)
    else:
        rep_seqs = rep_seqs[np.arange(0, trim_length)].copy()
        if pd.isnull(rep_seqs).any().any():
            warnings.warn("There are ASVs shorter than the trim length. "
                          "These sequences will be discarded.", UserWarning)
        rep_seqs.dropna(how='any',  axis=0, inplace=True)

    # Collapses the table based on the trimmed sequences
    table = table.filter(rep_seqs.index, axis='observation')
    sub_seq = pd.DataFrame(rep_seqs.apply(lambda x: ''.join(x), axis=1), 
                           columns=['representative-sequence'])
    table.add_metadata(sub_seq.to_dict(orient='index'), axis='observation')

    table2 = table.collapse(lambda id_, md: md['representative-sequence'], 
                            norm=False,
                            axis='observation')

    seqs2 = sub_seq.drop_duplicates()['representative-sequence'].copy()

    if hashed_feature_ids:
        table2.update_ids(
            {seq_: _hash_seq(seq_) for seq_ in table2.ids(axis='observation')},
            axis='observation',
            inplace=True
            )
        seqs2.rename({id_: _hash_seq(seq_) for id_, seq_ in seqs2.items()}, 
                    inplace=True)
    else:
        seqs2.rename({id_: seq_ for id_, seq_ in seqs2.items()}, 
                    inplace=True)

    seqs2 = _convert_seq_block_to_dna_fasta_format(
        [seqs2.apply(lambda x: pd.Series(list(x)))]
        )

    return table2, seqs2


def _hash_seq(x):
    return hashlib.md5(x.encode()).hexdigest()

